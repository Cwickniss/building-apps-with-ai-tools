# Modern Cursor Rules - Best Practices Example
# This demonstrates the current best practices for cursor rules

## Project Context
You are working on an educational project for teaching barefoot developers how to build simple web applications using AI tools. The focus is on practical, local-first applications that solve real problems without requiring professional development experience.

## Core Principles
- **Simplicity First**: Prioritize straightforward solutions that beginners can understand
- **Educational Value**: Every code example should teach a concept clearly
- **Local-First**: Applications should work without external servers when possible
- **AI-Friendly**: Code should be structured to work well with AI assistance

## Technical Standards

### HTML Structure
- Use semantic HTML5 elements (header, main, nav, section, article)
- Include proper meta tags for responsiveness and accessibility
- Add descriptive comments for educational purposes
- Keep markup clean and well-indented

### CSS Guidelines
- Mobile-first responsive design
- Use CSS custom properties for theming
- Prefer flexbox and grid over floats
- Include fallbacks for older browsers
- Comment complex styling decisions

### JavaScript Patterns
- Use modern ES6+ features with clear explanations
- Implement progressive enhancement
- Handle errors gracefully with user-friendly messages
- Use descriptive variable and function names
- Add JSDoc comments for all functions

### Example Code Structure
```javascript
/**
 * Saves user data to local storage
 * @param {string} key - Storage key name
 * @param {Object} data - Data to store
 * @returns {boolean} Success status
 */
function saveToLocalStorage(key, data) {
  try {
    localStorage.setItem(key, JSON.stringify(data));
    return true;
  } catch (error) {
    console.error('Storage error:', error);
    showUserMessage('Unable to save data locally');
    return false;
  }
}
```

## Security Requirements
- **Never expose API keys in frontend code**
- Always validate user input
- Use Content Security Policy headers
- Sanitize any dynamic content
- Implement rate limiting for API calls
- Store sensitive data only in secure backend services

## File Organization
```
project/
├── index.html          # Main entry point
├── styles/
│   ├── main.css       # Primary styles
│   └── themes.css     # Theme variations
├── scripts/
│   ├── app.js         # Main application logic
│   ├── utils.js       # Utility functions
│   └── api-proxy.js   # API handling
├── assets/
│   ├── images/
│   └── icons/
└── .cursorrules       # This file
```

## AI Assistance Guidelines

### When generating code:
1. Start with a working minimal example
2. Add features incrementally
3. Explain each major addition
4. Provide alternative approaches when relevant
5. Include error handling from the start

### When explaining concepts:
1. Use plain language first
2. Introduce technical terms gradually
3. Provide real-world analogies
4. Show before and after examples
5. Link to additional resources

## Common Patterns

### Local Storage Pattern
```javascript
const AppStorage = {
  save(key, data) {
    localStorage.setItem(`app_${key}`, JSON.stringify(data));
  },
  load(key) {
    const data = localStorage.getItem(`app_${key}`);
    return data ? JSON.parse(data) : null;
  },
  clear(key) {
    localStorage.removeItem(`app_${key}`);
  }
};
```

### API Proxy Pattern
```javascript
// Frontend: Never expose API keys
async function fetchWeatherData(city) {
  const response = await fetch('/api/weather', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ city })
  });
  return response.json();
}
```

### Error Handling Pattern
```javascript
async function safeApiCall(fn) {
  try {
    const result = await fn();
    return { success: true, data: result };
  } catch (error) {
    console.error('API Error:', error);
    return { 
      success: false, 
      error: 'Something went wrong. Please try again.' 
    };
  }
}
```

## Testing Guidelines
- Include simple console.log tests during development
- Create manual test checklists for each feature
- Test on multiple devices and browsers
- Ensure offline functionality works as expected

## Documentation Standards
- README should include clear setup instructions
- Document any API keys or services needed
- Provide example use cases
- Include screenshots or GIFs of the working app
- List known limitations and future improvements

## Accessibility Requirements
- All interactive elements must be keyboard accessible
- Include proper ARIA labels
- Ensure sufficient color contrast
- Test with screen readers
- Provide text alternatives for media

## Performance Considerations
- Minimize external dependencies
- Optimize images before use
- Implement lazy loading for heavy content
- Use CSS animations over JavaScript when possible
- Cache API responses appropriately

## Version Control
- Commit messages should be clear and descriptive
- Use .gitignore for sensitive files
- Branch names should reflect feature/fix purpose
- Tag releases with semantic versioning

Remember: The goal is to empower barefoot developers to create useful applications, not to build the next Facebook. Keep it simple, make it work, and help others learn.